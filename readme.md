### 华为软件挑战机器人运货刷榜挑战
#### 小队：代码敲得队

#### 项目构建

基于Cmake，通过键入以下命令生成可执行文件（请确保本地操作系统中安装了cmake和make 当然，还有C编译器，如果编译器没有选用gcc，适当修改CmakeLists.txt）

```
cd /build_[YOUR_OS]
cmake ..
make
```

生成的可执行文件main放置在 项目根目录/bin下

#### 项目运行
选择合适的判题器 (Robot 或 Robot_gui)
以下指令实现和判题器的交互
```
{ROBOT_PATH}/Robot[_gui] -m {MAP_FILE} {EXECUTABLE_FILE}
```
目前还未实现挂载在gdb上的断点调试，仍需学习

#### 输入

一个输入帧的格式如 项目根目录/test/input.txt所示，可以将其作为输入验证输出结果

#### 目前

实现了和判题器的联动
调度策略仍然需要改进


#### 介绍

请关注几个重要参数和我们存储的形式

+ 原材料编号

  标定原材料的唯一身份，为[1,7]之间的整数

  

+ 工作台ID
  标定每个工作台的唯一身份，为[0,当前场上工作台个数-1]

  ```
  //记录位置：
  
  struct _WorkBench wbList[WORKBENCHNUMBER]数组中以下标标定
  
  //使用情景：
  
  //机器人当前坐标命中了哪个工作台，由判题器给出
  size_t struct _Robot::localtion_wb_id
  ```

  

+ 工作台类型
  为[1,9]的整数，这决定当前工作台的输入和输出类型

  ```
  类型决定了工作台本身的消耗物品和生成物品，类型本身不作记录，而是记录于工作台的另外两个成员
  
  //工作台消耗的原材料编号
  size_t struct _WorkBench::neededItem
  //该数据以二进制位表描述  如00001100表示工作台消耗物品2和3
  
  //工作台生产的原材料编号
  size_t struct _WorkBench::produceItem
  //该数据以二进制位表描述  如00000010表示工作台生产物品1
  
  *二进制位表的最低位始终为0
  ```

  

+ 工作台原材料格状态

  这个数据记录了工作台当前拥有的原材料，由判题器给出

  ```
  //记录位置：
  
  size_t struct _WorkBench::ownItem
  //该数据以二进制位表描述  如00001100表示工作台已有物品2
  ```



+ 机器人ID

  标识了每个机器人的唯一身份，为[0,3]之间的整数

  ```
  //记录位置：
  
  size_t struct _Robot::botID
  
  //使用情景：
  
  //向判题器输出命令决定机器人行为
  命令： {botID} {forward/rotation/buy/sell}
  ```

  

+ 机器人携带原材料编号

  这个数据记录了机器人当前手持的原材料，由判题器给出

  ```
  /记录位置：
  
  size_t struct _Robot::carry_item
  //该数据以二进制位表描述  如00000010表示机器人正手持物品1
  ```

  



